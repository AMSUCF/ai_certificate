<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI in Digital Humanities Graduate Certificate</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f8f9fa;
        }
        header {
            position: relative;
            width: 100%;
            height: 60vh;
            overflow: hidden;
        }
        #headerCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .header-content {
            position: relative;
            z-index: 10;
            text-align: center;
            color: white;
            padding-top: 15vh;
        }
        .header-content h1 {
            font-size: 4em;
            font-weight: bold;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.6);
        }
        .header-content .sub-title {
            font-size: 1.5em;
            background-color: #ffcc00;
            color: black;
            padding: 0.3em 1em;
            display: inline-block;
            margin-top: 1rem;
        }
        .container {
            width: 90%;
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            opacity: 0;
            transform: translateX(-50%);
            transition: opacity 1s ease-out, transform 1s ease-out;
        }
        .container:nth-child(odd) {
            transform: translateX(-50%);
        }
        .container:nth-child(even) {
            transform: translateX(50%);
        }
        .container.visible {
            opacity: 1;
            transform: translateX(0);
        }
        .container h2 {
            color: #333;
            text-align: center;
        }
        .container p {
            line-height: 1.6;
            color: #555;
        }
        .highlight-course {
            background-color: #ffcc00;
            font-weight: bold;
            padding: 0.1em 0.3em;
        }
        .course-list {
            margin: 1rem 0;
        }
        .course-list li {
            line-height: 1.6;
            color: #555;
        }
        .elective-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            justify-content: space-between;
        }
        .elective-column {
            flex: 1;
            min-width: 300px;
        }
        .target-students {
            background-color: #ffcc00;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            color: #333;
            font-weight: bold;
        }
        footer {
            margin-top: 2rem;
            color: #666;
            text-align: center;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.0/lib/p5.min.js"></script>
</head>
<body>
    <header>
        <div id="headerCanvas"></div>
        <div class="header-content">
            <h1>Digital Humanities in the Age of AI</h1>
            <div class="sub-title">Graduate Certificate</div>
        </div>
    </header>
    
    <div class="container">
        <h2>About the Program</h2>
        <p>The Digital Humanities in the Age of AI certificate integrates perspectives from digital humanities, software studies, literary and cultural studies, digital rhetoric and composition, technical/professional writing, digital public history, and critical technology studies towards understanding and implementing digital humanities and artificial intelligence in our work and our classrooms.</p>
        <p>Intended to engage students with key areas of both digital humanities and AI, this interdisciplinary program is appropriate for students from any major or background. Students will engage in both critical and creative projects exploring the pitfalls and potentials of digital methods, including large language models, and build a historical understanding of the impacts of computational technologies across the humanities.</p>
        <p>Graduates will have a solid understanding of contemporary and historical issues and debates surrounding digital humanities and AI from an interdisciplinary humanities perspective. They will be prepared to engage in critical use of digital and AI tools and make informed decisions about the use of digital methods in their careers in humanities-related industries and classrooms.</p>
    </div>

    <div class="container">
        <h2><span class="highlight-course">Core Courses</span></h2>
        <ul class="course-list">
            <li>ENG6806: Humanities in the Age of AI - Core course exploring the impact of AI on the humanities.</li>
            <li>ENG6819: Critical Making for Humanist Scholarship - Practical and theoretical exploration of digital tools in humanities research.</li>
        </ul>
    </div>

    <div class="container">
        <h2><span class="highlight-course">Possible Electives Include:</span></h2>
        <div class="elective-container">
            <div class="elective-column">
                <ul class="course-list">
                    <li>DIG6436: Playable Texts and Technology</li>
                    <li>DIG6836: Humanistic Data Analysis</li>
                    <li>ENC6225: User-Centered Design for Technical Communication</li>
                    <li>ENC6421: Digital Rhetorics</li>
                </ul>
            </div>
            <div class="elective-column">
                <ul class="course-list">
                    <li>ENC6245: Teaching Professional Writing</li>
                    <li>HIS5925: History in the Digital Age</li>
                    <li>PHI6679: Digital Ethics</li>
                    <li>DIG5831: Computational Media</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container target-students">
        This certificate is suitable for educators and other working professionals seeking to advance their knowledge and skills in a holistic, humanities-focused program. Students choose from a flexible range of modality options: the program may be completed online based on course availability.
    </div>

    <div class="container">
        <h2>Program Prerequisites</h2>
        <p>The Graduate Certificate in Digital Humanities in the Age of AI is designed for students from diverse backgrounds who wish to:</p>
        <ul>
            <li>Deepen and broaden knowledge gained in a related bachelor's degree.</li>
            <li>Prepare for master's or PhD programs in the humanities, with an emphasis on emerging technology in the humanities.</li>
            <li>Complement current study in UCF graduate programs, particularly in the humanities.</li>
        </ul>
    </div>

    <footer>
        &copy; 2024 University of Central Florida - Graduate Certificate Program
    </footer>

    <script>
        let nodes = [];
        let tileImage, bugImage;
        let maxSpeed = 0.5;

        function preload() {
            tileImage = loadImage('tile.jpg');
            bugImage = loadImage('bug.png');
        }

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight * 0.6);
            canvas.parent(document.getElementById('headerCanvas'));

            // Spawn bugs at random positions on the edge of the canvas
            for (let i = 0; i < 50; i++) {
                let edge = floor(random(4));
                let x, y;
                if (edge === 0) { // Top edge
                    x = random(width);
                    y = 0;
                } else if (edge === 1) { // Right edge
                    x = width;
                    y = random(height);
                } else if (edge === 2) { // Bottom edge
                    x = random(width);
                    y = height;
                } else { // Left edge
                    x = 0;
                    y = random(height);
                }
                nodes.push(new Node(x, y));
            }
        }

        function draw() {
            // Draw the tiled background
            for (let x = 0; x < width; x += tileImage.width) {
                for (let y = 0; y < height; y += tileImage.height) {
                    image(tileImage, x, y);
                }
            }

            for (let i = nodes.length - 1; i >= 0; i--) {
                nodes[i].update();
                nodes[i].display();
                nodes[i].checkCollision(nodes);
                if (nodes[i].isOutOfBounds()) {
                    nodes.splice(i, 1);
                }
            }
            if (nodes.length < 50) {
                let edge = floor(random(4));
                let x, y;
                if (edge === 0) { // Top edge
                    x = random(width);
                    y = 0;
                } else if (edge === 1) { // Right edge
                    x = width;
                    y = random(height);
                } else if (edge === 2) { // Bottom edge
                    x = random(width);
                    y = height;
                } else { // Left edge
                    x = 0;
                    y = random(height);
                }
                nodes.push(new Node(x, y));
            }
        }

        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = random(60, 90); // Larger size range for bug images
                this.xSpeed = random(-maxSpeed, maxSpeed);
                this.ySpeed = random(-maxSpeed, maxSpeed);
                this.targetX = width / 2;
                this.targetY = height / 2;
            }

            update() {
                let angleToTarget = atan2(this.targetY - this.y, this.targetX - this.x);
                this.xSpeed = cos(angleToTarget) * maxSpeed;
                this.ySpeed = sin(angleToTarget) * maxSpeed;
                this.x += this.xSpeed;
                this.y += this.ySpeed;
            }

            display() {
                push();
                translate(this.x, this.y);
                let angle = atan2(this.ySpeed, this.xSpeed) + HALF_PI; // Rotate to correctly face direction of movement
                rotate(angle);
                imageMode(CENTER);
                image(bugImage, 0, 0, this.size, this.size); // Draw the bug image
                pop();
            }

            checkCollision(nodes) {
                for (let other of nodes) {
                    if (other !== this) {
                        let d = dist(this.x, this.y, other.x, other.y);
                        if (d < (this.size / 2 + other.size / 2)) {
                            // Simple collision response: reverse speed
                            this.xSpeed *= -1;
                            this.ySpeed *= -1;
                            other.xSpeed *= -1;
                            other.ySpeed *= -1;
                        }
                    }
                }
            }

            isOutOfBounds() {
                return (this.x < 0 || this.x > width || this.y < 0 || this.y > height);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight * 0.6);
        }

        // Intersection Observer to trigger animations when in view
        document.addEventListener("DOMContentLoaded", function() {
            const observerOptions = {
                root: null,
                rootMargin: "0px",
                threshold: 0.1
            };

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add("visible");
                        observer.unobserve(entry.target);
                    }
                });
            }, observerOptions);

            const containers = document.querySelectorAll(".container");
            containers.forEach(container => {
                observer.observe(container);
            });
        });
    </script>
</body>
</html>
